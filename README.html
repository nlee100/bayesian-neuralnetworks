<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Bayesian Learning Artificial Neural Networks for Modeling Survival Data</title>

<script src="README_files/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="README_files/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="README_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="README_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="README_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="README_files/navigation-1.1/tabsets.js"></script>
<script src="README_files/navigation-1.1/codefolding.js"></script>
<link href="README_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="README_files/highlightjs-9.12.0/highlight.js"></script>
<script src="README_files/kePrint-0.0.1/kePrint.js"></script>
<link href="README_files/lightable-0.0.1/lightable.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>





<style type="text/css">
/* for pandoc --citeproc since 2.11 */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>




</head>

<body>


<div class="container-fluid main-container">




<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Bayesian Learning Artificial Neural Networks for Modeling Survival Data</h1>

</div>

<div id="TOC">
<ul>
<li><a href="#motivation"><span class="toc-section-number">1</span> Motivation</a></li>
<li><a href="#but-what-are-neural-networks"><span class="toc-section-number">2</span> But what are neural networks?</a></li>
<li><a href="#the-artificial-neural-network-approach-to-modeling-survival-data"><span class="toc-section-number">3</span> The Artificial Neural Network Approach to modeling survival data</a></li>
<li><a href="#bayesian-approach-to-inference-using-ann"><span class="toc-section-number">4</span> Bayesian approach to inference using ANN</a></li>
<li><a href="#bayesian-based-neural-networks-for-modeling-survival-using-micro-array-data"><span class="toc-section-number">5</span> Bayesian-based neural networks for modeling survival using micro-array data</a>
<ul>
<li><a href="#introduction-and-data-description"><span class="toc-section-number">5.1</span> Introduction and data description</a></li>
<li><a href="#exploratory-data-analysis-and-deg-identification"><span class="toc-section-number">5.2</span> Exploratory data analysis and DEG identification</a></li>
</ul></li>
<li><a href="#neural-networks-with-bayesian-learning"><span class="toc-section-number">6</span> Neural Networks with Bayesian Learning</a></li>
<li><a href="#discussion"><span class="toc-section-number">7</span> Discussion</a></li>
<li><a href="#python-extension"><span class="toc-section-number">8</span> Python extension</a></li>
<li><a href="#references"><span class="toc-section-number">9</span> References</a></li>
</ul>
</div>

<style type="text/css">
/* Three image containers (use 25% for four, and 50% for two, etc) */
.column {
  float: left;
  width: 33.33%;
  padding: 5px;
}

/* Clear floats after image containers */
.row::after {
  content: "";
  clear: both;
  display: table;
}

</style>
<center>
<h1>
<p>Amos Okutse, Naomi Lee</p>
<p>12 May, 2022</p>
</h1>
<p><span></p>
<p></span></p>
</center>
<div id="motivation" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Motivation</h1>
<p>Accurate predictions of prognostic outcomes are of substantial and pivotal significance in the context of quality care delivery. However, the application of deep learning models to enhance caregiving in healthcare has been limited by concerns related to the reliability of such methods. In this way, models that are robust and which can result in a throughput prediction of such clinical outcomes as survival while at the same time exhibiting high reliability and potential to be generalized to larger populations remain in high demand. As a result, there has been an emerging persistent interest in modeling survival data to leverage the promise deep learning models offer in this regard. This is not surprising given the significance of the healthcare sector, where we are often interested in understanding, for instance, the role that a specific differentially expressed gene plays concerning prognosis or, more generally, understanding how a given treatment regimen is likely to impact patient outcomes and in turn make decisions accordingly to perhaps improve patient outcomes related to care.</p>
<p>Analyzing time-to-event data involves is an inimitable problem given that the outcome of interest might comprise whether or not an event has occurred (binary outcome) but also the time when this event occurs (continuous outcome) <span class="citation">(<a href="#ref-feng2021bdnnsurv" role="doc-biblioref">Feng and Zhao 2021</a>)</span>. The problem is further complicated by missing data on the survival outcome of interest—censored data.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. The very nature of (censored) survival data makes it impossible to apply classical analysis methods such as logistic regression.</p>
<p>Additionally, models based on the Weibull model have restrictive assumptions, including a parametric form of the distribution of the time to event. Similarly, the semi-parametric Cox proportional hazards (PH) model <span class="citation">(<a href="#ref-burden2008bayesian" role="doc-biblioref">Burden and Winkler 2008</a>)</span> also has assumptions, a major one being the proportional hazards assumption: “the effect of a unit increase in a covariate is multiplicative with respect to the hazard rate.” Despite the outcome of interest not always being a hazard rate, it can be a probability; for instance, the PH assumption does not make much sense, especially when we have a substantial number of covariates (we would need each of these covariates to satisfy this assumption). The performance of these methods has also been shown to be poor, especially when the underlying model is incorrectly specified <span class="citation">(<a href="#ref-feng2021bdnnsurv" role="doc-biblioref">Feng and Zhao 2021</a>)</span>.</p>
<p>But how can we tackle the problem of modeling survival data amicably? This post reviews an extension of artificial neural networks (ANN) implemented based on the Cox PH model and trained to model survival data using Bayesian learning. In particular, we use a 2-layer feed-forward artificial neural network (ANN) trained using Bayesian inference to model survival outcomes and compare this model to the more traditional Cox proportional hazards model. Compared to previously studied models, we expect the ANN trained using Bayesian inference to perform better following its incorporation of Bayesian inference and neural networks.</p>
<p>First, we introduce <em>neural networks in a more general context</em>, then discuss <em>the neural networks approach to modeling survival data</em> and how Bayesian inference has been introduced into these models to enhance their predictive capacity. Next, we introduce an application of the Bayesian learning artificial neural network (BLNN) using an R package of a similar name applied in modeling the effect of identified differentially expressed genes on the survival of patients with primary bladder cancer. Lastly, we compare this model to the more traditional Cox PH model for illustrative purposes and provide an extension code in Python.</p>
</div>
<div id="but-what-are-neural-networks" class="section level1" number="2">
<h1><span class="header-section-number">2</span> But what are neural networks?</h1>
<p>With all the hype linked to this deep learning method in the recent past <span class="citation">(<a href="#ref-hastie2009elements" role="doc-biblioref">Hastie et al. 2009</a>)</span>, we provide a simplistic idea of what this method is. Defined: Neural networks are:</p>
<blockquote>
<p>“Computer systems with interconnected nodes designed like neurons to mimic the human brain in terms of intelligence. These networks use algorithms to discover hidden data structures and patterns, correlations, clusters, and classify them, learn and improve over time.”</p>
</blockquote>
<p>The idea is to take in simple functions as inputs and then allow these functions to build upon each other. The models are flexible enough to learn non-linear relationships rather than prescribing them as is in kernels or transformations. A neural network takes in an input vector of p features <span class="math inline">\(X=(X_1, X_2, \cdots , X_p)\)</span> and then creates a non-linear function to forecast an outcome variable, <span class="math inline">\(Y\)</span>. While varied statistical models such as Bayesian additive regression trees (BART) and random forests exist, neural networks have a structure that contrasts them from these other methods. Figure 1 shows a feed-forward neural network with an input layer consisting of 4 input features, <span class="math inline">\(X=(X_1, \cdots, X_4)\)</span>, a single hidden layer with 5 nodes <span class="math inline">\(A_1, \cdots, A_5\)</span>, a non-linear activation function, <span class="math inline">\(f(X)\)</span> (output layer), and the desired outcome, <span class="math inline">\(Y.\)</span></p>
<p><img src="basic_neural_1.jpg" /></p>
<p>The arrows show that the input layer is feeding into each of the nodes in the hidden layer which in turn feed into our activation function all the way to the outcome in a forward manner hence the name—“feed forward.” A general neural network model has the form:</p>
<p><span class="math display">\[\begin{align}
 f(X) &amp; = \beta_0 + \sum_{k=1}^{K} \beta_k h_k (X)\\
&amp; = \beta_0 + \sum_{k=1}^{K} \beta_k g(w_{k0} + \sum_{j=1}^{p}w_{kj}X_j)
\end{align}\]</span></p>
<p>In the first modeling step, the <span class="math inline">\(K\)</span> activations in the hidden layer are computed as functions of the features in the input layer, that is:</p>
<p><span class="math display">\[\begin{align}
A_k = h_k(X) &amp;= g(w_{k0} + \sum_{j=1}^{p}w_{kj}X_j)\\
&amp; =~~\textrm {where} ~g(z) = \textrm{non-linear activation function which has to be specified.}
\end{align}\]</span></p>
<p>The <span class="math inline">\(K\)</span> activation functions from the hidden layer then feed their outputs into the output layer so that we have:</p>
<p><span class="math display">\[\begin{align}
 f(X) &amp; = \beta_0 + \sum_{k=1}^{K} \beta_k A_k
\end{align}\]</span></p>
<p>where <span class="math inline">\(K\)</span> in Figure 1 is 5. Parameters <span class="math inline">\(\beta_0, \cdots, \beta_K\)</span>, as well as, <span class="math inline">\(w_{10}, \cdots, w_{Kp}\)</span> are estimated from the data. Quite a number of options exist for the activation function, <span class="math inline">\(g(z).\)</span><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> The non-linearity of the activation function <span class="math inline">\(g(z)\)</span> allows the model to capture complex non-linear structures as well as interaction effects.</p>
</div>
<div id="the-artificial-neural-network-approach-to-modeling-survival-data" class="section level1" number="3">
<h1><span class="header-section-number">3</span> The Artificial Neural Network Approach to modeling survival data</h1>
<p>The BLNN implementation of Bayesian inference in artificial neural networks is based on the Cox PH-based neural model described by <span class="citation"><a href="#ref-sharaf2015two" role="doc-biblioref">Sharaf and Tsokos</a> (<a href="#ref-sharaf2015two" role="doc-biblioref">2015</a>)</span>. In particular, the idea is to build a predictive model for survival using a neural network with <span class="math inline">\(K\)</span> outputs. <span class="math inline">\(K\)</span> here defines the number of periods. Using this neural network architecture, Mani et al. estimated a hazard function where for each individual, we have a training vector a $1 K $ of hazard probabilities <span class="math inline">\((h_{ik})\)</span> defined as:
<span class="math display">\[ 
h_{ik}=
\begin{cases}
0 &amp; ~\textrm{if} ~ 1\leq k \leq K \\
1 &amp;~\textrm{if} ~ t \leq k \leq K ~ \textrm{and event = 1} \\
\frac{r_k}{n_k}~ \textrm{if}~ t \leq k \leq K ~ \textrm{and event = 0}
\end{cases}
\]</span>
where <span class="math inline">\(h_{ik}=0\)</span> if the event of interest did not occur (patient survived), <span class="math inline">\(h_{ik} =1\)</span> if event occurred at some time, <span class="math inline">\(t\)</span> and <span class="math inline">\(h_{ik}=\frac{r_k}{n_k}\)</span> if the subject is censored/ lost to follow -up during the course of the study, <span class="math inline">\(t&lt;K\)</span>. <span class="math inline">\(h_{ik}=\frac{r_k}{n_k}\)</span> is the Kaplan-Meier (KM) hazard estimate for time interval <span class="math inline">\(k\)</span> and <span class="math inline">\(r_k\)</span> and <span class="math inline">\(n_k\)</span> denote the number of events due to the risk factor of interest in time period <span class="math inline">\(k\)</span> and the number at risk in time interval <span class="math inline">\(k.\)</span> The neural network uses the logistic sigmoid activation function defined as:
<span class="math display">\[
\Phi (x) = \frac{1}{1+e^{-x}}
\]</span></p>
<p>The weights for this network are obtained through a minimization of the cross-entropy loss function<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>. Figure 2 shows the architecture of a feed-forward neural network based on the Cox PH model with an input layer consisting of <span class="math inline">\(p\)</span> covariates and a bias term, a single hidden layer with <span class="math inline">\(H\)</span> nodes, and a single bias term. Lastly, we have an output layer with <span class="math inline">\(K\)</span> units, which learn to estimate the hazard probabilities associated with each individual at each time interval. The network’s input layer feeds the hidden layer, which in turn feeds the output layer. The “feed-forward” naming convention is derived from this aspect of the architecture. The hazard estimates based on this neural network model are then converted to estimates of survival based on the survival function:</p>
<p><span class="math display">\[
S(t_k)=\prod_{l=1}^k (1-h(t_l))
\]</span></p>
<p>where <span class="math inline">\(k\)</span> denotes the disjoint intervals and <span class="math inline">\(l\)</span> the number of time periods in which the event occurred.</p>
<p><img src="cox_net.png" /></p>
</div>
<div id="bayesian-approach-to-inference-using-ann" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Bayesian approach to inference using ANN</h1>
<p>This post focuses on inference using a two-layer feed-forward artificial neural network. Specifically, we describe the Bayesian learning neural networks implemented by <span class="citation"><a href="#ref-sharaf2020blnn" role="doc-biblioref">Sharaf et al.</a> (<a href="#ref-sharaf2020blnn" role="doc-biblioref">2020</a>)</span> on a neural network-based implementation of the Cox proportional hazard model described above. In training neural networks using conventional methodologies, the aim is to find a local minimum of the error function, an ideology that makes model selection rather difficult. Additionally, as described elsewhere by <span class="citation">(<a href="#ref-hastie2009elements" role="doc-biblioref">Hastie et al. 2009</a>)</span>, the training of neural networks presents such an issue as overfitting, a situation where, even though the model performs extremely well on the training data, it fails to generalize well on resampling or when applied on unobserved data. Overfitting has been linked to these models having too many weights such that they overfit at the global minimum of <span class="math inline">\(R\)</span> <span class="citation">(<a href="#ref-lawrence1997lessons" role="doc-biblioref">Lawrence, Giles, and Tsoi 1997</a>; <a href="#ref-hastie2009elements" role="doc-biblioref">Hastie et al. 2009</a>)</span>. According to <span class="citation"><a href="#ref-burden2008bayesian" role="doc-biblioref">Burden and Winkler</a> (<a href="#ref-burden2008bayesian" role="doc-biblioref">2008</a>)</span> :</p>
<blockquote>
<p>“Bayesian regularized artificial neural networks (BRANNs) are more robust than standard backpropagation nets and can reduce or eliminate the need for lengthy cross-validation.”</p>
</blockquote>
<p>In the Bayesian context, the idea is to use prior information about the distribution of the parameter of interest, update this information using the sample data and obtain a posterior distribution for the parameter, <span class="math inline">\(\theta\)</span>. BLNN tries to present Hamiltonian energy, <span class="math inline">\(H(w, p)= U(w)+K(p)\)</span> as a joint probability distribution of the neural network’s weights, <span class="math inline">\(w\)</span> and momentum, <span class="math inline">\(\textbf{p}\)</span>. Given independence between <span class="math inline">\(w\)</span> and <span class="math inline">\(\textbf{p}\)</span>, this joint probability is defined as:</p>
<p><span class="math display">\[
P(w, p) = (\frac{1}{z} exp^{-U(w)/z})(\frac{1}{T}exp^{-K(p)/T})
\]</span>
where:
<span class="math inline">\(U(w) =\)</span> the negative log-likelihood of the posterior distribution defined as <span class="math inline">\(U(w)=-log[p(w)L(w|D)]\)</span>
<span class="math inline">\(L(w|D) =\)</span> the likelihood function given the data <br>
$K(p) = _{i=1}<sup>{d}(P_i</sup>2)/(2m_i) $ is the kinetic energy corresponding to the negative log-likelihood of the normal distribution with mean, <span class="math inline">\(\mu\)</span> and variance-covariance matrix with diagonal elements, <span class="math inline">\(M=(m_1, \cdots, m_d)\)</span><br>
<span class="math inline">\(Z\)</span> and <span class="math inline">\(T\)</span> are the normalizing constants.</p>
<p>The algorithm is summarized as below:</p>
<p><img src="blnn_algorithm.jpg" />
Source: Sharaf et. al (2020)</p>
<p>Details about the implementation of this method can be found <a href="https://rdrr.io/github/BLNNdevs/BLNN/#vignettes">here</a>.</p>
<p><span class="citation"><a href="#ref-sharaf2020blnn" role="doc-biblioref">Sharaf et al.</a> (<a href="#ref-sharaf2020blnn" role="doc-biblioref">2020</a>)</span> utilize a no-U-turn sampler (NUTS), an extension of Hamiltonian Monte-Carlo (HMC) that seeks to reduce the dependence on the number of step parameters used in HMC while retaining the efficiency in generating independent samples. The ANN is trained using both HMC and NUTS with dual averaging. The negative log-likelihood is replaced by network errors, and backpropagation is used to compute the gradients. Network errors and weights are assumed to be normally distributed with mean, <span class="math inline">\(\mu\)</span> but with a non-constant variance, <span class="math inline">\(\sigma^2\)</span>. The variance of the prior is known by the precision parameter, <span class="math inline">\(\tau = \frac{1}{\sigma^2}\)</span> aka the hyperparameters which are either assigned to fixed, fine-tuned values or re-estimated based on historical data. The list of hyperparameters allowed in the BLNN implementation is discussed elsewhere <span class="citation">(<a href="#ref-sharaf2020blnn" role="doc-biblioref">Sharaf et al. 2020</a>)</span>. The following section provides a sample application of BLNNs applied to real-world data.</p>
</div>
<div id="bayesian-based-neural-networks-for-modeling-survival-using-micro-array-data" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Bayesian-based neural networks for modeling survival using micro-array data</h1>
<div id="introduction-and-data-description" class="section level2" number="5.1">
<h2><span class="header-section-number">5.1</span> Introduction and data description</h2>
<p>In our analyses in this section, we employ data consisting of 256 samples prepared using the Illumina Human-6 expression BeadChip Version 2.0 to identify DEGs and use bayesian neural networks to identify how these genes impact survival in patients with primary bladder cancer. The data relates to 165 primary bladder cancer samples and nine normal cells downloaded from the Gene Expression Omnibus (GEO) <span class="citation">(<a href="#ref-kim2010predictive" role="doc-biblioref">Kim et al. 2010</a>; <a href="#ref-okutse2021differential" role="doc-biblioref">Okutse and Nyongesa 2021</a>)</span>.</p>
<pre class="r"><code>#load the data from the GEO
gset &lt;- getGEO(&quot;GSE13507&quot;, GSEMatrix =TRUE, AnnotGPL=TRUE)
if (length(gset) &gt; 1) idx &lt;- grep(&quot;GPL6102&quot;, attr(gset, &quot;names&quot;)) else idx &lt;- 1
gset &lt;- gset[[idx]]

# make proper column names to match toptable 
fvarLabels(gset) &lt;- make.names(fvarLabels(gset))

# group names for all samples
gsms &lt;- paste0(&quot;0000000000XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;,
               &quot;XXXXXXXXXXXXXXXXXX22222222222222222222222222222222&quot;,
               &quot;22222222222222222222222222222222222222222222222222&quot;,
               &quot;22222222222222222222222222222222222222222222222222&quot;,
               &quot;222222222222222222222222222222222XXXXXXXXXXXXXXXXX&quot;,
               &quot;XXXXXX&quot;)
sml &lt;- c()
for (i in 1:nchar(gsms)) { sml[i] &lt;- substr(gsms,i,i) }

# eliminate samples marked as &quot;X&quot;
sel &lt;- which(sml != &quot;X&quot;)
sml &lt;- sml[sel]
gset &lt;- gset[ ,sel]

# log2 transform
exprs(gset) &lt;- log2(exprs(gset))

# set up the data and proceed with analysis
sml &lt;- paste(&quot;G&quot;, sml, sep=&quot;&quot;)    # set group names
fl &lt;- as.factor(sml)
gset$description &lt;- fl
design &lt;- model.matrix(~ description + 0, gset)
colnames(design) &lt;- levels(fl)
fit &lt;- lmFit(gset, design)
cont.matrix &lt;- makeContrasts(G2-G0, levels=design)
fit2 &lt;- contrasts.fit(fit, cont.matrix)
fit2 &lt;- eBayes(fit2, 0.01)

tT &lt;- topTable(fit2, adjust=&quot;fdr&quot;, sort.by=&quot;B&quot;, number=Inf) 
#tt&lt;-subset(tT, select=c(&quot;Gene.symbol&quot;,&quot;logFC&quot;,&quot;AveExpr&quot;,&quot;t&quot;,&quot;P.Value&quot;,&quot;adj.P.Val&quot;,&quot;B&quot;))
#dat&lt;-subset(tT, select=c(&quot;Gene.symbol&quot;,&quot;logFC&quot;,&quot;adj.P.Val&quot;))</code></pre>
</div>
<div id="exploratory-data-analysis-and-deg-identification" class="section level2" number="5.2">
<h2><span class="header-section-number">5.2</span> Exploratory data analysis and DEG identification</h2>
<p>First, we perform some exploratory data analysis on these data. We perform data transformation including sample normalization and log2 transformation then use eBayes<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a> to fit a model for differential expression analysis. We then present a sample of 10 up and down regulated genes in Table <a href="#tab:table1">5.1</a>. In Figure <a href="#fig:mean-difference">5.1</a> we visualize the differentially expressed genes in this sample using a mean-difference plot.</p>
<pre class="r"><code>#top regulated genes
upregulated&lt;-tT[which(tT$logFC&gt;0),][1:10,]
#upregulated
upregulated&lt;-subset(upregulated, select=c(&quot;Gene.ID&quot;, &quot;Gene.symbol&quot;,&quot;logFC&quot;,&quot;AveExpr&quot;,&quot;adj.P.Val&quot;,&quot;B&quot;))
##getting top 10 downregulated genes
downreg&lt;-tT[which(tT$logFC&lt;0),][1:10,]
downreg&lt;-subset(downreg, select=c(&quot;Gene.ID&quot;,&quot;Gene.symbol&quot;,&quot;logFC&quot;,&quot;AveExpr&quot;,&quot;adj.P.Val&quot;,&quot;B&quot;))

deg&lt;-rbind(upregulated, downreg) 
rownames(deg)&lt;-NULL
deg%&gt;% kable(format = &quot;html&quot;, 
             caption = &quot;Top 10 up and down regulated genes in primary bladder cancer. The first 10 rows represent upregulated genes&quot;,
             col.names = c(&quot;Gene ID&quot;, &quot;Gene Symbol&quot;, &quot;logFC&quot;, &quot;Average Expression&quot;, &quot;Adjusted P-value&quot;, &quot;B&quot;)) %&gt;%
  kable_styling(full_width = FALSE, latex_options = c(&quot;HOLD_position&quot;, &quot;stripped&quot;, &quot;scale_down&quot;), position = &quot;left&quot;)</code></pre>
<table class="table" style="width: auto !important; ">
<caption>
<span id="tab:table1">Table 5.1: </span>Top 10 up and down regulated genes in primary bladder cancer. The first 10 rows represent upregulated genes
</caption>
<thead>
<tr>
<th style="text-align:left;">
Gene ID
</th>
<th style="text-align:left;">
Gene Symbol
</th>
<th style="text-align:right;">
logFC
</th>
<th style="text-align:right;">
Average Expression
</th>
<th style="text-align:right;">
Adjusted P-value
</th>
<th style="text-align:right;">
B
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
991
</td>
<td style="text-align:left;">
CDC20
</td>
<td style="text-align:right;">
0.4715744
</td>
<td style="text-align:right;">
3.448492
</td>
<td style="text-align:right;">
0e+00
</td>
<td style="text-align:right;">
15.80790
</td>
</tr>
<tr>
<td style="text-align:left;">
5373
</td>
<td style="text-align:left;">
PMM2
</td>
<td style="text-align:right;">
0.1710619
</td>
<td style="text-align:right;">
3.338349
</td>
<td style="text-align:right;">
0e+00
</td>
<td style="text-align:right;">
15.27138
</td>
</tr>
<tr>
<td style="text-align:left;">
128239
</td>
<td style="text-align:left;">
IQGAP3
</td>
<td style="text-align:right;">
0.4125383
</td>
<td style="text-align:right;">
3.340340
</td>
<td style="text-align:right;">
0e+00
</td>
<td style="text-align:right;">
14.95455
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:right;">
0.2268436
</td>
<td style="text-align:right;">
3.233782
</td>
<td style="text-align:right;">
0e+00
</td>
<td style="text-align:right;">
13.79589
</td>
</tr>
<tr>
<td style="text-align:left;">
2932
</td>
<td style="text-align:left;">
GSK3B
</td>
<td style="text-align:right;">
0.1896154
</td>
<td style="text-align:right;">
3.377058
</td>
<td style="text-align:right;">
1e-07
</td>
<td style="text-align:right;">
12.82440
</td>
</tr>
<tr>
<td style="text-align:left;">
51537
</td>
<td style="text-align:left;">
MTFP1
</td>
<td style="text-align:right;">
0.2168117
</td>
<td style="text-align:right;">
3.393753
</td>
<td style="text-align:right;">
2e-07
</td>
<td style="text-align:right;">
12.03233
</td>
</tr>
<tr>
<td style="text-align:left;">
51203
</td>
<td style="text-align:left;">
NUSAP1
</td>
<td style="text-align:right;">
0.3719761
</td>
<td style="text-align:right;">
3.344562
</td>
<td style="text-align:right;">
3e-07
</td>
<td style="text-align:right;">
11.28112
</td>
</tr>
<tr>
<td style="text-align:left;">
7153
</td>
<td style="text-align:left;">
TOP2A
</td>
<td style="text-align:right;">
0.4546483
</td>
<td style="text-align:right;">
3.341922
</td>
<td style="text-align:right;">
4e-07
</td>
<td style="text-align:right;">
11.09297
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:right;">
0.0471829
</td>
<td style="text-align:right;">
2.866252
</td>
<td style="text-align:right;">
5e-07
</td>
<td style="text-align:right;">
10.82223
</td>
</tr>
<tr>
<td style="text-align:left;">
2810
</td>
<td style="text-align:left;">
SFN
</td>
<td style="text-align:right;">
0.3100817
</td>
<td style="text-align:right;">
3.493720
</td>
<td style="text-align:right;">
8e-07
</td>
<td style="text-align:right;">
10.18284
</td>
</tr>
<tr>
<td style="text-align:left;">
9890
</td>
<td style="text-align:left;">
PLPPR4
</td>
<td style="text-align:right;">
-0.3804426
</td>
<td style="text-align:right;">
2.891050
</td>
<td style="text-align:right;">
0e+00
</td>
<td style="text-align:right;">
50.66289
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:right;">
-0.0622618
</td>
<td style="text-align:right;">
2.808016
</td>
<td style="text-align:right;">
0e+00
</td>
<td style="text-align:right;">
42.95524
</td>
</tr>
<tr>
<td style="text-align:left;">
54360
</td>
<td style="text-align:left;">
CYTL1
</td>
<td style="text-align:right;">
-0.2690733
</td>
<td style="text-align:right;">
2.886378
</td>
<td style="text-align:right;">
0e+00
</td>
<td style="text-align:right;">
41.75689
</td>
</tr>
<tr>
<td style="text-align:left;">
11126
</td>
<td style="text-align:left;">
CD160
</td>
<td style="text-align:right;">
-0.1475023
</td>
<td style="text-align:right;">
2.853721
</td>
<td style="text-align:right;">
0e+00
</td>
<td style="text-align:right;">
38.93153
</td>
</tr>
<tr>
<td style="text-align:left;">
121601
</td>
<td style="text-align:left;">
ANO4
</td>
<td style="text-align:right;">
-0.1705039
</td>
<td style="text-align:right;">
2.827650
</td>
<td style="text-align:right;">
0e+00
</td>
<td style="text-align:right;">
36.38865
</td>
</tr>
<tr>
<td style="text-align:left;">
5126
</td>
<td style="text-align:left;">
PCSK2
</td>
<td style="text-align:right;">
-0.1268787
</td>
<td style="text-align:right;">
2.823028
</td>
<td style="text-align:right;">
0e+00
</td>
<td style="text-align:right;">
34.23361
</td>
</tr>
<tr>
<td style="text-align:left;">
9745
</td>
<td style="text-align:left;">
ZNF536
</td>
<td style="text-align:right;">
-0.2280635
</td>
<td style="text-align:right;">
2.898368
</td>
<td style="text-align:right;">
0e+00
</td>
<td style="text-align:right;">
34.04707
</td>
</tr>
<tr>
<td style="text-align:left;">
55022
</td>
<td style="text-align:left;">
PID1
</td>
<td style="text-align:right;">
-0.3029122
</td>
<td style="text-align:right;">
2.899585
</td>
<td style="text-align:right;">
0e+00
</td>
<td style="text-align:right;">
33.04130
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:right;">
-0.2550758
</td>
<td style="text-align:right;">
2.837756
</td>
<td style="text-align:right;">
0e+00
</td>
<td style="text-align:right;">
32.74756
</td>
</tr>
<tr>
<td style="text-align:left;">
10699
</td>
<td style="text-align:left;">
CORIN
</td>
<td style="text-align:right;">
-0.1867473
</td>
<td style="text-align:right;">
2.868771
</td>
<td style="text-align:right;">
0e+00
</td>
<td style="text-align:right;">
32.25715
</td>
</tr>
</tbody>
</table>
<div class="figure"><span style="display:block;" id="fig:mean-difference"></span>
<img src="README_files/figure-html/mean-difference-1.png" alt="A mean-difference plot showing the statistically significantly up and down regulated genes in primary bladder cancer relative to normal bladder cells."  />
<p class="caption">
Figure 5.1: A mean-difference plot showing the statistically significantly up and down regulated genes in primary bladder cancer relative to normal bladder cells.
</p>
</div>
<p>Additionally, we perform a basic functional enrichment analysis using Gene Ontology (GO) enrichment analysis and a small fraction of the DEGs (n = 300 genes) to identify the pathways where this statistically significantly differentially expressed genes are enriched. Here, we use a basic barplot to visualize the most common GO terms. We note in Figure <a href="#fig:enrich">5.2</a> that some of these genes are involved in a number of biological functions including synapse organization as well as junction assembly and neural migration.</p>
<pre class="r"><code>#using clusteRprofiler to get the networks of genes in relation to function
#cnetplot(edo, foldChange = gene_symbols, circular=TRUE, colorEdge = TRUE, showCategory = 20)
#barplots of the similar results showing only 20 enrichment categories
barplot(edo, showCategory=10, cex.names=3)</code></pre>
<div class="figure"><span style="display:block;" id="fig:enrich"></span>
<img src="README_files/figure-html/enrich-1.png" alt="Sample Enrichment analysis results using the Gene Ontology (GO) enrichment analysis."  />
<p class="caption">
Figure 5.2: Sample Enrichment analysis results using the Gene Ontology (GO) enrichment analysis.
</p>
</div>
</div>
</div>
<div id="neural-networks-with-bayesian-learning" class="section level1" number="6">
<h1><span class="header-section-number">6</span> Neural Networks with Bayesian Learning</h1>
<p>The data used in this analysis consists of 43148 observations on 256 variables. First, we begin by cleaning up the data in preparation for downstream analysis and then select a sample of genes for our analysis here. For brevity we perform analyses on a sample of n=2000 genes.</p>
<p>Here, we install package <code>remotes</code> and then use it to install the development version of the BLNN package which allows us to use Bayesian learning neural networks and apply these to our dataset. We install this package using the command <code>remotes::install_github("BLNNdevs/BLNN")</code> and then select a sample of about 1375 gene probes to use in downstream analysis.</p>
<pre class="r"><code>#install the package BLNN
#install.packages(&quot;remotes&quot;)
#remotes::install_github(&quot;BLNNdevs/BLNN&quot;)
library(BLNN)
#load the probes to be used in analysis
probes&lt;-read.csv(&quot;probs.csv&quot;)
coxdata&lt;-coxdata[, 8:ncol(coxdata)]
#filter the data to only selected probes from the probes data file
names&lt;-names(coxdata) %in% probes$x
coxdata&lt;-coxdata[, names]
#add the survival data column to this subset data
coxdata$overall_survival&lt;-overall_survival
#coxdata&lt;-data.frame(overall_survival, coxdata)
#str(coxdata)

#create a matrix from the data
mod&lt;-model.matrix(overall_survival~.,
                  data = coxdata)
#create the training matrix of covariates and the response vector, y
trainx&lt;-mod[, 2:ncol(mod)]
trainy&lt;-coxdata$overall_survival</code></pre>
<pre class="r"><code>#build the BLNN object
survObj&lt;-BLNN_Build(ncov = 1375, nout = 1, hlayer_size = 10,
                    actF = &quot;tanh&quot;, outF = &quot;sigmoid&quot;, cost = &quot;crossEntropy&quot;,
                    hp.Err = 20, hp.W1 = rep(1, ncol(trainx)), hp.W2 = 1,
                    hp.B1 = 1, hp.B2 = 1)
#print(survObj)</code></pre>
<pre class="r"><code>trainxx&lt;-coxdata[,1:1375]
#network weights
n.par&lt;-length(BLNN_GetWts(survObj))
#number of desired chains
chains&lt;-2
#initials weight values
initials&lt;-lapply(1:chains, function(i) rnorm(length(BLNN_GetWts(survObj)), 0, 1/sqrt(n.par)))

#variance for the moments
m1&lt;-rep(1/2, n.par)
#trainx&lt;-as.array(trainx)
#start the training
#trainxx&lt;-array(trainx, dim = c(165, 1375, 0))

survNUTS&lt;-BLNN_Train(survObj, x=trainxx, y=trainy,
                     iter = 5000, thin = 10, warmup = 400,
                     init = initials, chains = chains,
                     algorithm = &quot;HMC&quot;, evidence = FALSE,
                     control = list(adapt_delta=0.99, momentum_mass=m1, 
                                    stepsize=1, gamma=15, to=10, useDA=TRUE,
                                    max_treedepth=20))</code></pre>
<pre class="r"><code>#model predictions without evidence
predicted1&lt;-BLNN_Predict(survObj, trainx, fit = survNUTS)
#predict using the neural network with evidence
#predicted2&lt;-BLNN_Predict(survObj, trainx, fit = survNUTS.ev)</code></pre>
</div>
<div id="discussion" class="section level1" number="7">
<h1><span class="header-section-number">7</span> Discussion</h1>
</div>
<div id="python-extension" class="section level1" number="8">
<h1><span class="header-section-number">8</span> Python extension</h1>
</div>
<div id="references" class="section level1" number="9">
<h1><span class="header-section-number">9</span> References</h1>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-burden2008bayesian" class="csl-entry">
Burden, Frank, and Dave Winkler. 2008. <span>“Bayesian Regularization of Neural Networks.”</span> <em>Artificial Neural Networks</em>, 23–42.
</div>
<div id="ref-feng2021bdnnsurv" class="csl-entry">
Feng, Dai, and Lili Zhao. 2021. <span>“BDNNSurv: Bayesian Deep Neural Networks for Survival Analysis Using Pseudo Values.”</span> <em>arXiv Preprint arXiv:2101.03170</em>.
</div>
<div id="ref-hastie2009elements" class="csl-entry">
Hastie, Trevor, Robert Tibshirani, Jerome H Friedman, and Jerome H Friedman. 2009. <em>The Elements of Statistical Learning: Data Mining, Inference, and Prediction</em>. Vol. 2. Springer.
</div>
<div id="ref-kim2010predictive" class="csl-entry">
Kim, Wun-Jae, Eun-Jung Kim, Seon-Kyu Kim, Yong-June Kim, Yun-Sok Ha, Pildu Jeong, Min-Ju Kim, et al. 2010. <span>“Predictive Value of Progression-Related Gene Classifier in Primary Non-Muscle Invasive Bladder Cancer.”</span> <em>Molecular Cancer</em> 9 (1): 1–9.
</div>
<div id="ref-lawrence1997lessons" class="csl-entry">
Lawrence, Steve, C Lee Giles, and Ah Chung Tsoi. 1997. <span>“Lessons in Neural Network Training: Overfitting May Be Harder Than Expected.”</span> In <em>AAAI/IAAI</em>, 540–45. Citeseer.
</div>
<div id="ref-okutse2021differential" class="csl-entry">
Okutse, Amos, and Kelvin Nyongesa. 2021. <span>“Differential Expression Analysis for the Identification of Survival Associated Genes in Primary Bladder Cancer Using Microarray Data.”</span> <em>International Journal of Undergraduate Research and Creative Activities</em> 13 (1).
</div>
<div id="ref-sharaf2015two" class="csl-entry">
Sharaf, Taysseer, and Chris P Tsokos. 2015. <span>“Two Artificial Neural Networks for Modeling Discrete Survival Time of Censored Data.”</span> <em>Advances in Artificial Intelligence</em> 2015.
</div>
<div id="ref-sharaf2020blnn" class="csl-entry">
Sharaf, Taysseer, Theren Williams, Abdallah Chehade, and Keshav Pokhrel. 2020. <span>“BLNN: An r Package for Training Neural Networks Using Bayesian Inference.”</span> <em>SoftwareX</em> 11: 100432.
</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Censoring refers to a concept in survival analysis where the actual time to event is unknown due to such reasons as the loss to follow up, withdrawals, or an exact unknown time of event. In right censoring, the event of interest occurs after the end of the experiment or study, whereas in left censoring, the event occurs before the onset of the study. Interval censoring is when the actual survival time is bounded between some interval<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>Common activation functions include the sigmoid activation function favoured in classification problems, the rectified linear unit (ReLU) favoured in linear regression problems, tanh, and leaky ReLU.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p> formula defined here<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p>link here<a href="#fnref4" class="footnote-back">↩︎</a></p></li>
</ol>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeCodeFolding("hide" === "show");
});
</script>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_CHTML.js";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
